/*
 * Copyright 2009-2014 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package retrieval.client;

import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.log4j.Logger;
import org.jdom.Document;
import retrieval.dist.MessageError;
import retrieval.dist.MultiServerMessageNBT;
import retrieval.dist.MultiServerMessageResults;
import retrieval.dist.MultiServerMessageSimilarities;
import retrieval.dist.NotValidMessageXMLException;
import retrieval.dist.ResultsSimilarities;
import retrieval.exception.CBIRException;
import retrieval.storage.index.ResultSim;
import retrieval.utils.NetworkUtils;

/**
 * Client side of Communication class between Client and servers
 * with XML message and TCP/IP Socket
 * @author Rollus Loic
 */
public class RetrievalClientToServersXML{

    /**
     * Server list
     */
    private final ListServerInformationSocket listsServer;
    /**
     * Logger
     */
    private static final Logger logger = Logger.getLogger(RetrievalClientToServersXML.class);

    /**
     * Launch communication class on server
     * @param listsServer List of server
     */
    public RetrievalClientToServersXML(ListServerInformationSocket listsServer) {
        this.listsServer = listsServer;
    }

    /**
     * This function search similar picture with the help of visualwords
     * generated by Iq (request image).
     * @param visualWords Visual words of Iq
     * @param N Number of patch extracted from Iq
     * @param k Max similar picture from each server
     * @param storages Search only on these storages (null or empty = all storages)
     * @return Max k*S similar pictures and a list of server state
     * @throws InterruptedException Internal error during search
     */
    public ResultsSimilarities searchMultiThread(List<ConcurrentHashMap<String, Long>> visualWords, int N, int k, String[] storages) throws InterruptedException {

        if (logger.isDebugEnabled()) {
            logger.debug("searchMultiThread: N=" + N + " T=" + visualWords.size() + " k=" + k);
            logger.debug("searchMultiThread: build first message...");
        }
        //ask for nbt on each server
        logger.debug("getNBTFromServers");
        MultiServerMessageSimilarities msgNBT = getNBTFromServers(visualWords, N, k,storages);
        //ask for similar pictures on each server thanks to nbt
        logger.debug("getMostSimilarPictureFromServers");
        MultiServerMessageResults msgSimilar[] = getMostSimilarPictureFromServers(msgNBT);
        //filter most similar picture (sort + filter k first)
        logger.debug("sortAndTrimBestResults");
        ResultsSimilarities results = sortAndTrimBestResults(msgSimilar, k);
        //fill the size of each server index (number of picture
        logger.debug("fillSizeOfServer");
        fillSizeOfServer(msgSimilar, results);
        logger.debug("results");
        try {listsServer.closeAll();}catch(Exception e) {logger.warn(e);}
        return results;
    }
    /**
     * Sort similarities for all server response
     * @param msg3s All servers responses
     * @param k Max similar picture for each server (optimization parameter)
     * @return All servers responses sorted
     */
    protected List<ResultSim> sortSimilarities(MultiServerMessageResults[] msg3s, int k) {
        //results will have the max size of number of similar picture (k) * number of server
        List<ResultSim> results = new ArrayList<ResultSim>(k * msg3s.length);
        for (MultiServerMessageResults msg3 : msg3s) {
            if (msg3 != null) {
                Map<String,List<ResultSim>> allServerSim = msg3.getResults();
                Iterator<Entry<String,List<ResultSim>>> it = allServerSim.entrySet().iterator();
                while(it.hasNext()) {
                    Entry<String,List<ResultSim>> entry = it.next();
                    List<ResultSim> sim = entry.getValue();
                    results.addAll(sim);
                }
            }      
        }
        Collections.sort(results);
        return results;
    }


    protected ResultsSimilarities sortAndTrimBestResults(MultiServerMessageResults msgSimilar[], int k) {
        return new ResultsSimilarities(sortSimilarities(msgSimilar, k),listsServer);
    }

    protected void fillSizeOfServer(MultiServerMessageResults[] msgSimilar, ResultsSimilarities results) {
        for (int i = 0; i < msgSimilar.length; i++) {
            if (msgSimilar[i] != null) {
                long sizeOfIndex = msgSimilar[i].getNumberOfPicturesInIndex();
                results.add((int)sizeOfIndex);
            }
        }
    }

    /**
     * Get all NBT info on each server
     * @param visualWords Visualword to check NBT
     * @param N Number of patch
     * @param k Number of max result
     * @return Message with sum of NBT from each server
     * @throws InterruptedException
     */
    protected MultiServerMessageSimilarities getNBTFromServers(List<ConcurrentHashMap<String, Long>> visualWords, int N, int k, String[] servers) throws InterruptedException {
        Map<String,List<ConcurrentHashMap<String, Long>>> visualWordsMap = new TreeMap<String,List<ConcurrentHashMap<String, Long>>>();
        visualWordsMap.put("#all#", visualWords);

        MultiServerMessageNBT msgVW = new MultiServerMessageNBT(visualWordsMap,servers);
        MultiServerMessageSimilarities msgSimilar = new MultiServerMessageSimilarities(visualWordsMap, N, k,servers);

        List<Integer> serverKeys = listsServer.getKeys();
        ClientAskNbtThread[] threadsNBT = new ClientAskNbtThread[listsServer.size()];
        for (int i = 0; i < serverKeys.size(); i++) {
            Integer serverKey = serverKeys.get(i);
            //if server is OK, try to send message
            threadsNBT[i] = new ClientAskNbtThread(msgVW, msgSimilar, listsServer.get(serverKey));
            threadsNBT[i].start();
            logger.error("searchMultiThread1: ok=" + listsServer.get(serverKey).toString());
        }

        //wait all server similar pictures
        for (ClientAskNbtThread threadsNBT1 : threadsNBT) {
            if (threadsNBT1 != null) {
                threadsNBT1.join();
            }
        }
        return msgSimilar;
    }

    /**
     * Get Most Similar Pictures
     * @param msgWithNBT Message with NBT
     * @return Result for each server
     * @throws InterruptedException
     */
    protected MultiServerMessageResults[] getMostSimilarPictureFromServers(MultiServerMessageSimilarities msgWithNBT) throws InterruptedException {
        /*
         * Ask Similarity between visual word from Iq and index of each server
         */
        ClientAskSimilaritiesThread[] threadsSimilar = new ClientAskSimilaritiesThread[listsServer.size()];
        MultiServerMessageResults[] msg3s = new MultiServerMessageResults[listsServer.size()];

        logger.debug("searchMultiThread: compute results");
        List<Integer> serverKeys = listsServer.getKeys();
        for (int i = 0; i < serverKeys.size(); i++) {
            Integer serverKey = serverKeys.get(i);
            //get the results only if server has send NBT...
            if (listsServer.get(serverKey).getState() == ServerInformationSocket.NOERROR) {
                threadsSimilar[i] = new ClientAskSimilaritiesThread(msgWithNBT, msg3s, i, listsServer.get(serverKey));
                threadsSimilar[i].start();
                logger.info("searchMultiThread2: ok=" + i);
            } else {
                logger.error("searchMultiThread2: nok=" + i);
            }
        }

        //Wait each server response
        for (ClientAskSimilaritiesThread threadsSimilar1 : threadsSimilar) {
            if (threadsSimilar1 != null) {
                threadsSimilar1.join();
            }
        }
        return msg3s;
    }
    
     /**
     * Get the number of servers
     * @return Number of servers
     */
    public int getNumberOfServer() {
        return listsServer.size();
    }   
}

/**
 * This Thread ask NBT on a specific server
 * @author Rollus Loic
 */
class ClientAskNbtThread extends Thread {

    private MultiServerMessageNBT msgSource;
    private MultiServerMessageSimilarities msgResult;
    private ServerInformationSocket server;
    private static Logger logger = Logger.getLogger(ClientAskNbtThread.class);

    /**
     * Constructor
     * @param msgSource Message with NBT (Source: IN)
     * @param msgResult Message build with similarity (Result: OUT)
     * @param server Server index
     */
    ClientAskNbtThread(
            MultiServerMessageNBT msgSource,
            MultiServerMessageSimilarities msgResult,
            ServerInformationSocket server) {
        this.msgSource = msgSource;
        this.msgResult = msgResult;
        this.server = server;
    }

    @Override
    public void run() {

        try {
            server.connect();
            //set max wait for a server
            //write message
            logger.debug("ClientAskNbtThread run nbt: 1 write msg1 to " + server);

            NetworkUtils.writeXmlToSocket(server.getSocket(), msgSource.toXML());
            //read reponse
            logger.debug("ClientAskNbtThread run nbt: 2 read msg1 from " + server);
            Document msg1xml = NetworkUtils.readXmlFromSocket(server.getSocket());

            logger.debug("ClientAskNbtThread run nbt: 3 read msg1 from " + server);
            //check if error message
            if (MessageError.isErrorMessage(msg1xml)) {
                throw MessageError.getException(msg1xml);
            }
            //otherwise, complete result
            msgResult.addNBT(msg1xml);
            logger.debug("ClientAskNbtThread run nbt: 4 read msg1 from " + server);
        } catch (SocketTimeoutException e) {
            logger.error("run nbt: timeout:" + e);
            server.changeState(ServerInformationSocket.TIMEOUT, e.getMessage());
        } catch (SocketException e) {
            logger.error("run nbt: lost:" + e);
            server.changeState(ServerInformationSocket.LOST, e.getMessage());
        } catch (NotValidMessageXMLException e) {
            logger.error("run nbt: msg:" + e);
            server.changeState(ServerInformationSocket.UNDEF, e.getMessage());
        } catch (CBIRException e) {
            logger.error("run nbt: servor:" + e);
            server.changeState(ServerInformationSocket.SERVERERROR, e.getMessage());
        } catch (Exception e) {
            logger.error("run nbt: undef:" + e);
            server.changeState(ServerInformationSocket.UNDEF, e.getMessage());
        }
    }
}

/**
 * This Thread ask similar pictures on a server
 * @author Rollus Loic
 */
class ClientAskSimilaritiesThread extends Thread {

    private MultiServerMessageSimilarities msgToSend;
    private MultiServerMessageResults[] msgToReceive;
    private ServerInformationSocket server;
    private int numberOfThread;
    private static Logger logger = Logger.getLogger(ClientAskSimilaritiesThread.class);

    ClientAskSimilaritiesThread(MultiServerMessageSimilarities msgToSend, MultiServerMessageResults[] msgToReceive, int numberOfThread, ServerInformationSocket server) {
        this.msgToSend = msgToSend;
        this.msgToReceive = msgToReceive;
        this.server = server;
        this.numberOfThread = numberOfThread;
    }

    @Override
    public void run() {

        try {
            //write request
            logger.debug("ClientAskSimilaritiesThread run sim: 1 write message...:");
            NetworkUtils.writeXmlToSocket(server.getSocket(), msgToSend.toXML());
            //read response
            logger.debug("ClientAskSimilaritiesThread run sim: 2 read response...");
            Document msg3xml = NetworkUtils.readXmlFromSocket(server.getSocket());
            logger.debug("ClientAskSimilaritiesThread run sim: 3 read response...");
            //if error message, throw it
            if (MessageError.isErrorMessage(msg3xml)) {
                throw MessageError.getException(msg3xml);
            }
            //else add similarity on array
            msgToReceive[numberOfThread] = new MultiServerMessageResults(msg3xml);
            logger.debug("ClientAskSimilaritiesThread run sim: 4 read response...");
        } catch (SocketTimeoutException e) {
            logger.error("run sim: timeout " + e);
            server.changeState(ServerInformationSocket.TIMEOUT, e.getMessage());
        } catch (SocketException e) {
            logger.error("run sim: lost " + e);
            server.changeState(ServerInformationSocket.LOST, e.getMessage());
        } catch (CBIRException e) {
            logger.error("run sim: servor " + e);
            server.changeState(ServerInformationSocket.SERVERERROR, e.getMessage());
        } catch (Exception e) {
            logger.error("run sim: undef " + e);
            server.changeState(ServerInformationSocket.UNDEF, e.getMessage());
        }
    }
}